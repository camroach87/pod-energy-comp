---
title: "Explore data"
author: "Cameron Roach"
date: "04/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(betareg)
library(gbm)
library(lubridate)

demand_df <- read_csv("../inst/extdata/pod_ds_task0/demand_train_set0.csv")
weather_df <- read_csv("../inst/extdata/pod_ds_task0/weather_train_set0.csv")
pv_df <- read_csv("../inst/extdata/pod_ds_task0/pv_train_set0.csv") %>% 
  rename(irradiance_Wm2 = `irradiance_Wm-2`) %>% 
  mutate(period = hour(datetime)*2 + minute(datetime)/30 + 1)
```

# Forecasting

Two elements to forecast: electricity demand and solar generation. Electricity demand will be predicted using:

* Temperature data of 6 weather stations
* Solar irradiance at 6 weather stations
* Appropriate lags of weather data
* Period of day
* Day of week effects
* Day of year effects
* Holidays
* Trend

Solar generation will be dependent on:

* Solar irradiance
* Panel temperature.

However, since we don't have the panel solar irradiance or temperature during the forecast period we may need to estimate these values using weather station data. Alternatively, we may only explore the relationship between PV generation and the surrounding weather stations (i.e. ignore panel irradiance and temperature data).

# Correlations

## Electricity demand

Many papers already explore this. Remember to

* Fit model for each hour.
* Compensate for daylight savings. Maybe separate hours?
* Maybe separate models for summer + shoulders and winter + shoulders? Or just Summer separately since it's UK?

```{r}
demand_df %>% 
  mutate(date = date(datetime),
         period = 2*hour(datetime) + minute(datetime)/30 + 1) %>% 
  ggplot(aes(x = period,
             y = demand_MW,
             colour = date,
             group = date)) + 
  geom_line()
```

```{r}
demand_df %>% 
  mutate(period = 2*hour(datetime) + minute(datetime)/30 + 1,
         wday = wday(datetime, label=T)) %>% 
  filter(period %in% 32:42) %>% 
  ggplot(aes(x = wday, y = demand_MW)) + 
  geom_boxplot()
```


## PV generation

### Relationship between panel variables

```{r}
pv_df %>% 
  ggplot(aes(x = datetime, y = pv_power_mw)) +
  geom_line()

pv_df %>% 
  # mutate(panel_temp_C_bin = cut_interval(panel_temp_C, n = 5)) %>% 
  ggplot(aes(x = irradiance_Wm2, y = pv_power_mw, colour = panel_temp_C)) +
  geom_point(shape = "O") +
  scale_colour_viridis_c()
```
Maximum generation is below rated 5 MW due to system losses such as: dirt, wiring voltage drops, inverter efficiency, temperature loss and manufacturer tolerances.

```{r}
pv_df %>% 
  mutate(pv_power_tf = log(pv_power_mw/(max(pv_power_mw, na.rm = T) - pv_power_mw))) %>% 
  ggplot(aes(x = irradiance_Wm2, y = pv_power_tf, colour = panel_temp_C)) +
  geom_point(shape = "O") +
  scale_colour_viridis_c()

inv_logit <- function(x) {
  return(1/(1+exp(-x)))
}

pv_df %>% 
  mutate(pv_power_tf = inv_logit(pv_power_mw)) %>% 
  ggplot(aes(x = irradiance_Wm2, y = pv_power_tf, colour = panel_temp_C)) +
  geom_point(shape = "O") +
  scale_colour_viridis_c()
```


```{r}
max_pv_gen <- max(pv_df$pv_power_mw, na.rm=T)

# For scaling justification, see https://stats.stackexchange.com/questions/31300/dealing-with-0-1-values-in-a-beta-regression
pv_train_df <- pv_df %>% 
  mutate(pv_power_sc = ((n()-1)*pv_power_mw/max_pv_gen + 0.5)/n()) %>% 
  na.omit()
train_idx <- sample(1:nrow(pv_train_df), .8*nrow(pv_train_df))
pv_test_df <- pv_train_df[-train_idx,]
pv_train_df <- pv_train_df[train_idx,]


# Linear regression
pv_lm2 <- lm(data = pv_train_df,
            formula = pv_power_mw ~ poly(irradiance_Wm2, 3) + irradiance_Wm2:panel_temp_C + panel_temp_C)
summary(pv_lm)

# Beta regression (constrained between 0 and 1)
pv_betareg <- betareg(data = pv_train_df,
                      formula = pv_power_sc ~ irradiance_Wm2*panel_temp_C)
summary(pv_betareg)

# GBM
pv_gbm <- gbm(data = pv_train_df,
              formula = pv_power_mw ~ irradiance_Wm2 + panel_temp_C,
              n.trees = 200,
              distribution = "gaussian",
              shrinkage = 0.1,
              interaction.depth = 3,
              n.minobsinnode = 10,
              bag.fraction = 0.5,
              var.monotone = c(1,0))

# Results
pv_test_df <- pv_test_df %>% 
  mutate(lm_pred = predict(pv_lm, newdata = .),
         lm_resid = pv_power_mw - lm_pred,
         betareg_pred = predict(pv_betareg, newdata = .) * max_pv_gen,
         betareg_resid = pv_power_mw - betareg_pred,
         gbm_pred = predict(pv_gbm, newdata = ., n.trees = pv_gbm$n.trees),
         gbm_resid = pv_power_mw - gbm_pred)

pv_test_df %>% 
  select(ends_with("resid")) %>% 
  pivot_longer(cols = everything(), names_pattern="(.*)_resid", names_to = "model", values_to = "residual") %>% 
  group_by(model) %>% 
  summarise(mae = mean(abs(residual), na.rm = T)) %>% 
  arrange(desc(mae))

pv_test_df %>% 
  select(irradiance_Wm2, panel_temp_C, pv_power_mw, ends_with("pred")) %>% 
  pivot_longer(cols = c(pv_power_mw, ends_with("pred"))) %>% 
  ggplot(aes(x = irradiance_Wm2, y = value, colour = panel_temp_C)) +
  geom_point(shape = "O") +
  facet_wrap(~name) +
  scale_colour_viridis_c()

pv_test_df %>% 
  select(ends_with("resid")) %>% 
  pivot_longer(cols = everything(), names_pattern="(.*)_resid", names_to = "model", values_to = "residual") %>% 
  ggplot(aes(x = residual, colour = model, fill = model)) +
  geom_density(alpha = 0.3)
```


## Weather station only?

What happens if we try to predict solar generation using weather station data only. How does it compare against a model based on panel specific data?

```{r}
pv_df %>%
  inner_join(weather_df, by = "datetime") %>% 
  select(datetime, pv_power_mw, 
         starts_with("solar_location"), 
         starts_with("temp_location")) %>% 
  pivot_longer(cols = -c(datetime, pv_power_mw),
               names_to = c("variable", "location"),
               names_pattern = "(.*)_location(.*)") %>% 
  pivot_wider(names_from = variable, values_from = value) %>% 
  ggplot(aes(x = solar, y = pv_power_mw, colour = temp)) +
  geom_point(shape = "O") +
  facet_wrap(~location) +
  scale_colour_viridis_c() +
  labs(title = "Correlation between weather station observations and solar panel generation.")

pv_df %>%
  inner_join(weather_df, by = "datetime") %>% 
  select(datetime, irradiance_Wm2, 
         starts_with("solar_location"), 
         starts_with("temp_location")) %>% 
  pivot_longer(cols = -c(datetime, irradiance_Wm2),
               names_to = c("variable", "location"),
               names_pattern = "(.*)_location(.*)") %>% 
  pivot_wider(names_from = variable, values_from = value) %>% 
  ggplot(aes(x = solar, y = irradiance_Wm2, colour = temp)) +
  geom_point(shape = "O") +
  facet_wrap(~location) +
  scale_colour_viridis_c() +
  labs(title = "Correlation between weather station observations and solar panel generation.")
```

Looks a lot noisier. Is it better to use weather data from weather stations to estimate irradiance and panel temperature (and then use the PV generation model), or is it more accurate the skip that step and jump straight to predicting PV generation using weather station observations?

Compare accuracy using cross-validation.
* *Method 1*: Predict panel temp and panel irradiance based on weather station observations. Then use estimated panel temp and panel irradiance to predict PV generation.
* *Model 2*: Predict PV generation using weather station observations.

```{r}
# Method 1
rm(pv_train_df, pv_test_df, pv_gbm)
train_df <- pv_df %>% 
  inner_join(weather_df, by = "datetime") %>% 
  na.omit()
# train_idx <- sample(1:nrow(train_df), .8*nrow(train_df))
train_idx <- 1:round(.8*nrow(train_df))
test_df <- train_df[-train_idx,] %>% 
  rename(panel_temp_C_obs = panel_temp_C,
         irradiance_Wm2_obs = irradiance_Wm2)
train_df <- train_df[train_idx,]

pv1_gbm <- gbm(data = train_df,
               formula = pv_power_mw ~ irradiance_Wm2 + panel_temp_C + period,
               n.trees = 200,
               distribution = "gaussian",
               shrinkage = 0.1,
               interaction.depth = 3,
               n.minobsinnode = 10,
               bag.fraction = 0.5,
               var.monotone = c(1,0,0))

panel_irradiance_gbm <- gbm(data = train_df %>% 
                              select(irradiance_Wm2, starts_with("temp_location"),
                                     starts_with("solar_location")),
                            formula = irradiance_Wm2 ~ .,
                            n.trees = 200,
                            distribution = "gaussian",
                            shrinkage = 0.1,
                            interaction.depth = 3,
                            n.minobsinnode = 10,
                            bag.fraction = 0.5)
summary(panel_irradiance_gbm, plotit = F)

panel_temp_gbm <- gbm(data = train_df %>% 
                        select(panel_temp_C, starts_with("temp_location"),
                               starts_with("solar_location")),
                      formula = panel_temp_C ~ .,
                      n.trees = 200,
                      distribution = "gaussian",
                      shrinkage = 0.1,
                      interaction.depth = 3,
                      n.minobsinnode = 10,
                      bag.fraction = 0.5)
summary(panel_temp_gbm, plotit = F)


m1_pred_df <- test_df %>% 
  mutate(panel_temp_C = predict(panel_temp_gbm, 
                                newdata = test_df, 
                                n.trees = panel_temp_gbm$n.trees),
         irradiance_Wm2 = predict(panel_irradiance_gbm, 
                                  newdata = test_df, 
                                  n.trees = panel_irradiance_gbm$n.trees)) %>% 
  mutate(pv_power_pred_1 = predict(pv1_gbm,
                                   newdata = .,
                                   n.trees = pv1_gbm$n.trees))
ggplot(m1_pred_df, aes(x = pv_power_mw, y = pv_power_pred_1)) + 
  geom_point()

# Method 2
pv2_gbm <- gbm(data = train_df %>% 
                 # select(pv_power_mw, period, starts_with("temp_location"),
                 #         starts_with("solar_location")),
                 select(pv_power_mw, period, matches("location[12]{1}")),
               formula = pv_power_mw ~ .,
               n.trees = 200,
               distribution = "gaussian",
               shrinkage = 0.1,
               interaction.depth = 5,
               n.minobsinnode = 10,
               bag.fraction = 0.5)

pv2_lm <- lm(data = train_df %>% 
                 select(pv_power_mw, period, matches("location[12]{1}")),
               formula = pv_power_mw ~ .)

m2_pred_df <- test_df %>% 
  mutate(pv_power_pred_2 = predict(pv2_gbm,
                                   newdata = .,
                                   n.trees = pv2_gbm$n.trees),
         pv_power_pred_2_lm = predict(pv2_lm, newdata = .))

# Compare
resid_df <- m2_pred_df %>% 
  select(datetime, pv_power_pred_2) %>% 
  inner_join(m1_pred_df, by = "datetime") %>% 
  mutate(resid_1 = pv_power_mw - pv_power_pred_1,
         resid_2 = pv_power_mw - pv_power_pred_2) %>% 
  select(resid_1, resid_2) %>% 
  pivot_longer(cols = everything(), names_to = "method", values_to = "resid", names_prefix = "resid_")

resid_df %>% 
  group_by(method) %>% 
  summarise(mae = mean(abs(resid), na.rm = T),
            sd = sd(resid, na.rm = T))

resid_df %>% 
  ggplot(aes(x = method, y = resid)) +
  geom_boxplot()

t.test(resid ~ method, resid_df)
```

Looking at this analysis there doesn't appear to be a statistically significant difference between the residuals of the two methods. Method 2 is thus preferable as it is easier to implement and is quicker to fit (only one model as opposed to three).



```{r}
# m2_pred_df %>% 
#   select(pv_power_mw, pv_power_pred_2, pv_power_pred_2_lm, irradiance_Wm2_obs) %>% 
#   pivot_longer(cols = -irradiance_Wm2_obs, names_prefix = "pv_power_") %>% 
#   ggplot(aes(x = irradiance_Wm2_obs, y = value)) + 
#   geom_point(shape = "O") +
#   facet_wrap(~name)

m2_pred_df %>% 
  select(datetime, pv_power_mw, pv_power_pred_2) %>% 
  pivot_longer(cols = -datetime, names_prefix = "pv_power_") %>% 
  mutate(date = date(datetime)) %>% 
  ggplot(aes(x = datetime, y = value)) + 
  geom_line(aes(colour = name)) +
  # geom_text(aes(label = date(datetime)), x=Inf, y=Inf) +
  facet_wrap(~date, scales = "free_x") +
  # theme(strip.background = element_blank(),
  #       strip.text.x = element_blank()) +
  scale_x_datetime(date_labels = "%H:%M")
```


Look at days where predictions are bad and try to understand why the generation has erratic drops. Most likely cloud coverage, so it will be interesting to look at daily profile of irradiance for two closest sites.

```{r}
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

test_df %>% 
  mutate(date = date(datetime)) %>% 
  # filter(between(date, ymd("2018-06-12"), ymd("2018-06-14"))) %>% 
  filter(date == ymd("2018-07-19")) %>% 
  select(datetime, irradiance_Wm2_obs, panel_temp_C_obs, starts_with("solar"), starts_with("temp")) %>% 
  pivot_longer(cols=-datetime) %>% 
  separate(name, c("var", "location"), "_location") %>% 
  mutate(location = case_when(var == "irradiance_Wm2_obs" ~ "panel",
                              var == "panel_temp_C_obs" ~ "panel",
                              TRUE ~ location),
         var = case_when(var == "irradiance_Wm2_obs" ~ "solar",
                         var == "panel_temp_C_obs" ~ "temp",
                         TRUE ~ var)) %>% 
  ggplot(aes(x = datetime, y = value, colour = location)) + 
  geom_line() +
  facet_wrap(~var, scales = "free_y") +
  scale_colour_manual(values = c(gg_color_hue(6), "black"))
```


After checking some of the dates with poor predictions, I can't see an obvious relationship between lagged solar values at weather stations and large prediction errors. It looks more like there are just random spikes/dips in irradiance at the solar panels which doesn't occur at the stations. Sometimes it also looks like very high panel temperatures sometimes result in random drops in PV generation. Again, these high panel temperatures don't appear to have any obvious correlation with weather station temperatures.

# Key modelling points

## PV generation

* There appears to be interaction between temperature and irradiance variables. GBM accounts for interactions as long as depth > 1.
* Need to forecast within limits (0-3.8?) for solar PV. Apparently it's a 5 MW solar farm but only 3.8 MW are produced at most due to system losses. Use historical max PV generation in order to determine appropriate upper bound.
* GBM seems to predict < 0 values for generation. Quick fix: if PV gen < 0 set equal to 0.


Enhancements after practice round: 

* Period of day added, but need to check it really improves model fit.
* GBM seems to predict < 0 values for generation. Not sure why this is happening, but may need to add in limits by transforming dependent variable.
* Include lags as the current panel temperature (which effects PV generation) will be dependent on historical temperatures over last few hours. Will also will help to factor in cloud coverage (was irradiance low nearby recently?).
* Maybe instead of lag, use change in values. Test to see which gives better results.
* For PV prediction - include differences in temp and irradiance between sites? Maybe just use two closest sites (location 1 and 2) for this.


## Electricity

Just do something similar to what I've done before. Can fine tune after practice round.

Will need to interpolate hourly weather data to half-hourly so that it can be joined up with half-hourly demand.

## TODO

* Haven't considered daylight savings times. Need to look into this
* GBM seems to work well for prediction. Should use it's out of bag error metrics for hyper-parameter tuning to make fitting efficient.
* Need to interpolate weather data to half-hourly and then calculate period.
* Make sure to use factor(period) if using it as a variable. Make sure factor levels match up if filtering the demand training data between 32 and 42 and then predicting on the unfiltered forecast data frame.

