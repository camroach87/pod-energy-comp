---
title: "Trial forecast"
author: "Cameron Roach"
date: "12/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(gbm)
library(lubridate)
```

## Load data

```{r}
demand_df <- read_csv("../inst/extdata/pod_ds_task0/demand_train_set0.csv") %>% 
  rename_all(tolower) %>% 
  mutate(wday = wday(datetime, label=T))

weather_df <- read_csv("../inst/extdata/pod_ds_task0/weather_train_set0.csv")
# interpolate from hourly to hh
# TODO: interpolate instead of filling
hh_dts <- seq(from=min(weather_df$datetime),
              to=max(weather_df$datetime) + 1800,
              by=1800)
hh_dts <- data.frame(datetime = hh_dts)

weather_df <- weather_df %>% 
  na.omit() %>% 
  full_join(hh_dts, by="datetime") %>% 
  arrange(datetime) %>% 
  fill(everything(), .direction = "down")  # TODO: interpolate linearly
  
  
pv_df <- read_csv("../inst/extdata/pod_ds_task0/pv_train_set0.csv") %>% 
  rename(irradiance_Wm2 = `irradiance_Wm-2`) %>% 
  rename_all(tolower)


fcst_dts <- ymd("2018-07-23") + days(0:6)
  
fcst_df <- weather_df %>% 
  filter(date(datetime) %in% fcst_dts) %>% 
  mutate(wday = wday(datetime, label=T))
```

## Fit models and forecast

```{r}
# PV
pv.train <- pv_df %>% 
  inner_join(weather_df, by="datetime") %>% 
  select(pv_power_mw, matches("location[12]{1}")) %>% 
  na.omit()
pv.gbm <- gbm(data = pv.train,
              formula = pv_power_mw ~ .,
              n.trees = 200,
              distribution = "gaussian",
              shrinkage = 0.1,
              interaction.depth = 5,
              n.minobsinnode = 10,
              bag.fraction = 0.5)
fcst_df$pv_power_mw <- predict(pv.gbm, 
                               newdata=fcst_df, 
                               n.trees=pv.gbm$n.trees)
# FIXME: implement better way to ensure pv > 0
fcst_df$pv_power_mw <- if_else(fcst_df$pv_power_mw < 0, 0, fcst_df$pv_power_mw)

# Demand
# TODO: interpolate weather data for half-hourly
# TODO: Add in period of day
demand.train <- demand_df %>% 
  inner_join(weather_df, by = "datetime") %>% 
  mutate(period = 2*hour(datetime) + minute(datetime)/30 + 1) %>% 
  filter(period %in% 32:42) %>%  # only predicting demand for periods of interest
  select(demand_mw, wday, matches("location[12]{1}")) %>% 
  na.omit()
demand.gbm <- gbm(data = demand.train,
              formula = demand_mw ~ .,
              n.trees = 200,
              distribution = "gaussian",
              shrinkage = 0.1,
              interaction.depth = 5,
              n.minobsinnode = 10,
              bag.fraction = 0.5)
fcst_df$demand_mw <- predict(demand.gbm, 
                             newdata=fcst_df, 
                             n.trees=pv.gbm$n.trees)
fcst_df <- fcst_df %>% 
  mutate(period = 2*hour(datetime) + minute(datetime)/30 + 1) %>% 
  mutate(demand_mw = if_else(!(period %in% 32:42), NA_real_, demand_mw))

# Check
fcst_df %>% 
  select(datetime, demand_mw, pv_power_mw) %>% 
  pivot_longer(-datetime) %>% 
  ggplot(aes(x = datetime, y = value, colour = name)) +
  geom_line()
```

## Schedule battery

```{r}
# TODO: add test to make sure columns are correctly ordered 1:48
P <- fcst_df %>% 
  mutate(date = date(datetime)) %>% 
  select(date, period, pv_power_mw) %>% 
  pivot_wider(id_cols = date, 
              names_from = period, 
              values_from = pv_power_mw) %>% 
  column_to_rownames("date") %>% 
  as.matrix()
B <- C <- matrix(0, nrow = 7, ncol = 48, dimnames = dimnames(P))

# Charge battery ====================================================
# Loop through each day and periods < 41 to charge battery
# Ignoring early morning periods as less charge produced
# TODO: fix so that battery can be fully charged taking a proportion of each periods PV gen to guard against under-forecasting PV. Charging as soon as possible risks taking in grid demand. If there is heaps of PV probably going to be produced later - just spread out the load a bit!
# Just using a naive method (scaling). See sc_fctr
c_idx <- 2:31  # charging period indices
for (iD in as.character(fcst_dts)) {
  # Total solar expected
  P_tot <- sum(P[iD,c_idx])
  sc_fctr <- 12/P_tot  # FIXME: this forces the battery to be fully charged and will take in grid demand potentially.
  
  for (iP in c_idx) {
    if (P[iD,iP] > 0) {
      B[iD,iP] <- min(sc_fctr*P[iD, iP], 2.5)
      C[iD,iP+1] <- C[iD,iP] + 0.5*B[iD,iP]  # 0.5 converts MW to MWh
      
      # check constraints
      if (C[iD,iP+1] > 6) {
        # FIXME: some rounding errors introduced when correcting for C > 6 MWh
        B[iD,iP] <- 2*(6 - C[iD,iP])
        C[iD,iP+1] <- 6
      } 
    }
  }
}

# FIXME: some rounding errors introduced when correcting for C > 6 MWh
matplot(t(B), type = "l")
matplot(t(C), type = "l")
table(C[,2:32] == 0.5*t(apply(B, 1, cumsum))[,1:31])
table(abs(C[,2:32] - 0.5*t(apply(B, 1, cumsum))[,1:31]) < 1e-12)
min(B, na.rm=T) >= 0
max(B, na.rm=T) <= 2.5
max(apply(t(B[,1:31]), 2, cumsum)) <= 12
max(apply(t(B[,1:31]), 2, cumsum)) - 12


# Discharging battery to reduce peak demand =========================
# TODO: Optimise this - more discharge during expected peak, etc.
# Currently using naive method - just taking max charge and evenly spreading across 32:42
# Have a look at how scaling for PV was done. Just grab demand, subtract the min and work out a scaling factor based on how much charge is available.
d_idx <- 32:42  # discharge period indices
for (iD in as.character(fcst_dts)) {
  # MW of battery discharge over hh
  dschrg_mw <- 2*C[iD,min(d_idx)]/length(d_idx)
  for (iP in d_idx) {
    if (C[iD,iP] > 0) {
      B[iD,iP] <- -1 * min(2.5, dschrg_mw)
      C[iD,iP+1] <- C[iD,iP] + 0.5*B[iD,iP]
    } else if (C[iD,iP] == 0) {
      # battery completely discharged so move to next day
      B[iD,iP:max(d_idx)] <- C[iD,(iP+1):(max(d_idx)+1)] <- 0
      break
    }
  }
}

B[,43:48] <- 0
C[,44:48] <- C[,43]

# checks
matplot(t(B), type = "l")
matplot(t(C), type = "l")
table(C[,2:32] == 0.5*t(apply(B, 1, cumsum))[,1:31])
table(abs(C[,2:32] - 0.5*t(apply(B, 1, cumsum))[,1:31]) < 1e-12)
max(B) <= 2.5
min(B) >= -2.5
max(C) <= 6
min(C) == 0
```



# Reformat

```{r}
bat_df <- B %>% 
  as_tibble(rownames = "date") %>% 
  pivot_longer(cols = -date,
               names_to = "period", 
               values_to = "charge_MW") %>% 
  mutate(period = as.numeric(period),
         datetime = as_datetime(date) + minutes(30*(period-1))) %>% 
  arrange(datetime) %>% 
  mutate(`_id` = row_number()) %>% 
  select(`_id`, datetime, charge_MW)

bla <- bat_df %>% group_by(date = date(datetime)) %>% mutate(cumsum_charge_MW = cumsum(charge_MW))
max(bla$cumsum_charge_MW) - 12 == 0

ggplot(bat_df, aes(x = datetime, y = charge_MW)) + 
  geom_line()

bat_df %>% 
  inner_join(fcst_df, by = "datetime") %>% 
  mutate(demand_red_mw = demand_mw,
         demand_red_mw = if_else(period %in% d_idx,
                                 demand_mw + charge_MW,
                                 demand_mw)) %>% 
  select(datetime, demand_mw, demand_red_mw) %>% 
  pivot_longer(cols = -datetime) %>% 
  ggplot(aes(x = datetime, y = value, colour = name)) +
  geom_line() +
  ylim(0, NA)
```

## Output results

```{r}
write_csv(battery_df,
          file = "../inst/extdata/pod_ds_task0/submission_template_set0")
```

